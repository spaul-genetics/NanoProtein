subset_nano_obj<-function(nano_obj, filter_by = NA, filter_str = NA, keep_id = NA, keep_feature = NA){
  ###
  # If keep_id or keep_feature is given then the object is subsetted based on sample or feature
  # No other operation will be performed in that case. 
  # If they are not given then the obsject will be subsetted based on filter_by slot and using filter_str expression
  
  nano_obj_subset = nano_obj
  if(!is.na(keep_id)){
    nano_obj_subset@id[keep_id,]
    nano_obj_subset@count<-nano_obj_subset@count[, rownames(nano_obj_subset@id)]
    nano_obj_subset@sample<-nano_obj_subset@sample[, rownames(nano_obj_subset@id)]
    return(nano_obj_subset)
  }
  
  
  if(!is.na(keep_feature)){
    nano_obj_subset@rows[keep_feature,]
    nano_obj_subset@count<-nano_obj_subset@count[rownames(nano_obj_subset@rows),]
    return(nano_obj_subset)
  }
  
  if(is.na(filter_by) | is.na(filter_str)){
    stop('filter_by or filter_for is missing')
  }
  
  eval(parse(text = paste0("keep = slot(nano_obj_subset, '", filter_by, "')$", filter_str)))
  
  slot(nano_obj_subset, filter_by) = slot(nano_obj_subset, filter_by)[keep,]
  if(filter_by == 'id'){
    nano_obj_subset@count<-nano_obj_subset@count[, rownames(nano_obj_subset@id)]
    nano_obj_subset@sample<-nano_obj_subset@sample[, rownames(nano_obj_subset@id)]
  }else{
    nano_obj_subset@count<-nano_obj_subset@count[rownames(nano_obj_subset@rows),]
  }
  return(nano_obj_subset)
}



qc_bar_plot<-function(nano_obj, filter_by, filter_for, annot_by){
  plot_data = data.frame(Log2GeoMean = colMeans(log2(nano_obj@count[grepl(filter_for, nano_obj@rows[[filter_by]]),])))
  plot_data$annot = unlist(nano_obj@id[[annot_by]])
  plot_data = plot_data[order(plot_data$Log2GeoMean),]
  ggplot(data = plot_data, aes(x = 1:nrow(plot_data),y = Log2GeoMean, fill = annot))+geom_bar(stat = 'identity')+
    theme_classic()  
}



qc_scatter<-function(nano_obj, color_by, shape_by = NA){
  plot_data = data.frame(
    exp(colMeans(log(nano_obj@count[grepl('Background',nano_obj@rows$Target_Group),]))),
    exp(colMeans(log(nano_obj@count[grepl('Housekeeping', nano_obj@rows$Target_Group),]))),
    unlist(nano_obj@id[[color_by]])
  )
  
  if(!is.na(shape_by)){
    plot_data[[shape_by]]<-unlist(nano_obj@id[[shape_by]])
    names(plot_data) = c('Background_geomean', 'Housekeeping_geomean', shape_by, color_by)
    fig = ggplot(data = plot_data, aes(x = Background_geomean, y = Housekeeping_geomean, shape = !!sym(shape_by), color = !!sym(color_by)))+geom_point()+
      theme_classic()
  }else{
    names(plot_data) = c('Background_geomean', 'Housekeeping_geomean', color_by)
    fig = ggplot(data = plot_data, aes(x = Background_geomean, y = Housekeeping_geomean, color = !!sym(color_by)))+geom_point()+
      theme_classic()
  }
   fig = fig + ggpubr::stat_cor(method = 'pearson')
  return(fig)
}


qc_pairs<-function(nano_obj, target, color_by, shape_by = NA){
  plot_data = data.frame(t(nano_obj@count[grepl(target, nano_obj@rows$Target_Group),]))
  if(!is.na(shape_by)){
    plot_data = cbind(plot_data, data.frame(Color = nano_obj@id[[color_by]], Shape = nano_obj@id[[shape_by]]))    
    names(plot_data)[names(plot_data)=='Shape']<-shape_by
  }else{
    plot_data = cbind(plot_data, data.frame(Color = nano_obj@id[[color_by]]))
  }

  names(plot_data)[names(plot_data)=='Color']<-color_by

  
  if(is.na(shape_by)){
    fig = GGally::ggpairs(plot_data, columns = 1:(ncol(plot_data)-1), aes(color = !!sym(color_by)))  
  }else{
    legend_plot = ggplot(data = plot_data, aes(x = !!sym(names(plot_data)[1]), y = !!sym(names(plot_data)[2]), shape = !!sym(shape_by) ))+geom_point()+theme(legend.position = 'bottom')
    legend = grab_legend(legend_plot)
    fig = GGally::ggpairs(plot_data, columns = 1:(ncol(plot_data)-2), aes(color = !!sym(color_by), shape = !!sym(shape_by)), legend = legend) + theme(legend.position = 'bottom')    
  }
  return(fig)  

}


qc_scatter_overall<-function(nano_obj, Area_column = 'AOI surface area', Nuclei_column = 'AOI nuclei count', color_by = 'Organism', shape_by = NA){
  plot_data = data.frame(
    IgG_geomean = exp(colMeans(log(nano_obj@count[grepl('IgG',rownames(nano_obj@count)),]))),
    HK_geomean = exp(colMeans(log(nano_obj@count[grepl('Housekeeping', nano_obj@rows$Target_Group),]))),
    Area = as.numeric(unlist(nano_obj@sample[Area_column,])),
    Nuclei = as.numeric(unlist(nano_obj@sample[Nuclei_column,])),
    Color = nano_obj@id[[color_by]] 
  )
  
  if(!is.na(shape_by)){
    plot_data$Shape = nano_obj@id[[shape_by]]
  }
  
  if(var(plot_data$Area)<0.001){
    plot_columns = c(1,2,4)
  }else{
    plot_columns = 1:4
  }
  if(is.na(shape_by)){
    fig = GGally::ggpairs(plot_data, columns = plot_columns, aes(color = Color))  
  }else{
    legend_plot = ggplot(data = plot_data, aes(x = IgG_geomean, y = HK_geomean, shape = Shape))+geom_point()+theme(legend.position = 'bottom')
    fig = GGally::ggpairs(plot_data, columns = plot_columns, aes(color = Color, shape = Shape), legend = grab_legend(legend_plot))+theme(legend.position = 'bottom')
  }
  return(fig)
}


signal_to_bg_ratio<-function(nano_obj){
  IgG_geomean = exp(colMeans(log(nano_obj@count[grepl('IgG', rownames(nano_obj@count)),])))
  
  plot_data = nano_obj@count%*%diag(1/IgG_geomean)
  plot_data = plot_data[!grepl('HYB',rownames(plot_data)),]
  plot_data = data.frame(t(plot_data))
  rownames(plot_data) = colnames(nano_obj@count)
  ordered_cols = names(plot_data)[order(colMeans(plot_data))]
  ordered_cols = c(grep('IgG', ordered_cols, value = T), ordered_cols[!grepl('IgG', ordered_cols)])
  plot_data = reshape2::melt(plot_data)
  plot_data$variable = factor(plot_data$variable, levels = ordered_cols)
  fig = ggplot(data = plot_data, 
               aes(x = variable, y = log2(value)))+
    geom_boxplot()+
    geom_jitter(alpha = 0.2, size = 0.5)+
    theme_bw()+
    theme(axis.text.x = element_text(angle = 90))+
    geom_hline(yintercept = 0)+
    labs(x = '', y = 'Log2 Signal-to-Background Ratio')
  return(fig)
}


count_boxplot<-function(nano_obj, by = 'feature', slot_id = 'count', array_name = NA, features = NA, filter_for = NA, color_by = NA){
  
  if(is.na(array_name)){
    if('list'%in%class(slot(nano_obj, 'count'))){
      stop('Your selected slot is a list of arrays. Provide array_name.')
    }
    plot_data = data.frame(slot(nano_obj, slot_id))  
  }else{
    plot_data = data.frame(slot(nano_obj, slot_id)[[array_name]])
    if(sum(dim(plot_data))==0){
      stop('No data found matching slot_id and array_name. Check your input.')
    }
  }
  
  
  if(!is.na(filter_for) & !is.na(features)){
    stop("Both filter_for and features can't be supplied")
  }
  
  if(!is.na(filter_for)){
    features = rownames(nano_obj@rows)[nano_obj@rows$CodeClass==filter_for]
    if(length(features)==0){
      stop(paste0('No ', filter_for, ' features found on CodeClass') )
    }
  }
  
  if(length(features)==1){
    if(!is.na(features)){
      plot_data = plot_data[features,]
    }  
  }
  
  
  
  plot_data = plot_data%>%tibble::rownames_to_column('Feature')%>%tidyr::pivot_longer(cols = !Feature, names_repair = 'check_unique')
  
  if(!is.na(color_by)){
    color_data = nano_obj@id
    color_data$name = make.names(rownames(color_data))
    color_data = color_data[,c(color_by, 'name')]
    plot_data = merge(plot_data, color_data, by = 'name')
  }
  
  if(by == 'feature'){
    
  
    if(is.na(color_by)){
      fig = ggplot(data = plot_data, aes(x = Feature, y = value))+
        geom_boxplot(outlier.shape = NA)+
        geom_jitter(size = 0.5) + 
        labs(y = 'Count')+
        theme_bw()+theme(axis.text.x = element_text(angle = 90))
    }else{
      fig = ggplot(data = plot_data, aes(x = Feature, y = value))+
        geom_boxplot(outlier.shape = NA)+
        geom_jitter(size = 0.5, aes(color = !!sym(color_by))) + 
        labs(y = 'Count')+
        theme_bw()+theme(axis.text.x = element_text(angle = 90))
    }
  }else{
    if(is.na(color_by)){
      fig = ggplot(data = plot_data, aes(x = name, y = value))+
        geom_boxplot(outlier.shape = NA)+
        geom_jitter(size = 0.5) + 
        labs(y = 'Count')+
        theme_bw()+theme(axis.text.x = element_text(angle = 90))
    }else{
      fig = ggplot(data = plot_data, aes(x = name, y = value))+
        geom_boxplot(outlier.shape = NA)+
        geom_jitter(size = 0.5, aes(color = !!sym(color_by))) + 
        labs(y = 'Count')+
        theme_bw()+theme(axis.text.x = element_text(angle = 90))
    }
  }
  
  return(fig)
}


normalize_nano<-function(nano_obj, method = 'bghk', out_name = NA, used_igg, used_hk){
  if(is.na(out_name)) out_name = method
  
  if(sum(nano_obj@rows$CodeClass=="Positive")>1){
    roiSpikein <-  apply(nano_obj@count[which(nano_obj@rows$CodeClass=="Positive"),], 2, geometric.mean)
    scale.factor <- roiSpikein/mean(roiSpikein) 
    if (any(scale.factor < 0.3 | scale.factor > 3)) {
      warning(cat("Identified positive scale factor outside recommended range \n(0.3-3).\nCheck samples prior to conducting analysis.\n", 
                  file = logfile, append = TRUE))
    }
    
  }else{
    roiSpikein <-  nano_obj@count[which(nano_obj@rows$CodeClass=="Positive"), ]
    scale.factor <- roiSpikein/mean(roiSpikein)
    if (any(scale.factor < 0.3 | scale.factor > 3)) {
      warning(cat("Identified positive scale factor outside recommended range \n(0.3-3).\nCheck samples prior to conducting analysis.\n",
                  file = logfile, append = TRUE))
    }
  }
  nano_obj@count_norm[['Positive']]<- sweep(nano_obj@count, 2, scale.factor, "/")
  
  if(method == 'posonly'){
    return(nano_obj)
  }
  
  if(method == 'bghk'){
    if(length(used_igg)==1){
      if(is.na(used_igg)){
        used_igg = grep('IgG', rownames(nano_obj@count), value = T)
      }      
    }

    if(length(used_hk)==1){
      if(is.na(used_hk)){
        used_hk = rownames(nano_obj@rows)[grepl('Housekeep',nano_obj@rows$Target_Group)]
      }
    }
    
    background_to_subtract = exp(colMeans(log(nano_obj@count_norm[['Positive']][used_igg,])))
    housekeeper_to_scale = exp(colMeans(log(nano_obj@count_norm[['Positive']][used_hk,])))
    housekeeper_to_scale = housekeeper_to_scale/mean(housekeeper_to_scale)
    endogenous <- rownames(nano_obj@rows)[nano_obj@rows$CodeClass=='Endogenous']
    #endogenous = setdiff(endogenous, unused_endo)
    count_after_bg_subt<- sweep(x = nano_obj@count_norm[['Positive']][endogenous,], MARGIN = 2, STATS = background_to_subtract)
    feature_with_low_count = unique(rownames(which(count_after_bg_subt<0, arr.ind = T)))
    if(length(feature_with_low_count)>0){
      message(paste0(paste(feature_with_low_count, collapse = ', '), ' have at least one ROI with less count than the background'))
    }

    nano_obj@count_norm[[out_name]] = sweep(x = count_after_bg_subt, MARGIN = 2, STATS = housekeeper_to_scale, FUN = '/') 
    return(nano_obj)  
  }
  
  
  if(method == 'Endogenous'){
    endogenous <- rownames(nano_obj@rows)[nano_obj@rows$CodeClass=='Endogenous']
    scale_factor = exp(colMeans(log(nano_obj@count_norm[['Positive']][endogenous,])))
    scale_factor = scale_factor/mean(scale_factor)
    nano_obj@count_norm[[out_name]] = sweep(x = nano_obj@count_norm[['Positive']][endogenous,], MARGIN = 2, STATS = scale_factor, FUN = '/')
    return(nano_obj)
  }
}



pca_plot<-function(nano_obj, slot_id = 'count', array_name = NA, x_index = 1, y_index = 2, color_by = NA){
  xaxis = paste0('PC', x_index)
  yaxis = paste0('PC', y_index)

  
  if(is.na(array_name)){
    x_mat = t(slot(nano_obj, slot_id))
  }else{
    x_mat = t(slot(nano_obj, slot_id)[[array_name]])  
  }
  
  prin_comp = prcomp(x_mat, scale = T, center = T)
  components <- prin_comp[['x']]
  components <- data.frame(components)
  if(!is.na(color_by)){
    components <- cbind(components, nano_obj@id)  
  }
  
  pov = 100*prin_comp$sdev^2/sum(prin_comp$sdev^2)
  xlab = paste0(xaxis, ' (', round(pov[x_index]),'%)')
  ylab = paste0(yaxis, ' (', round(pov[y_index]),'%)')
  if(is.na(color_by)){
    fig = ggplot(data = components, aes(x = !!sym(xaxis), y = !!sym(yaxis)))+geom_point()+theme_bw()+
      labs(x = xlab, y = ylab)
  }else{
    fig = ggplot(data = components, aes(x = !!sym(xaxis), y = !!sym(yaxis), color = !!sym(color_by)))+geom_point()+theme_bw()+
      labs(x = xlab, y = ylab)  
  }
  return(fig)
  
}


umap_plot<-function(nano_obj, slot_id = 'count', array_name = NA, color_by = 'Status'){
  if(is.na(array_name)){
    x_mat = t(slot(nano_obj, slot_id))
  }else{
    x_mat = t(slot(nano_obj, slot_id)[[array_name]])  
  }
  nano.umap = umap::umap(x_mat)
  plot_data = data.frame(nano.umap$layout)
  if(!is.na(color_by)){
    plot_data = cbind(plot_data, nano_obj@id)  
  }
  
  if(is.na(color_by)){
    fig = ggplot(data = plot_data, aes(x = X1, y = X2))+geom_point()+theme_bw()+labs( x = 'UMAP1', y = 'UMAP2')
  }else{
    fig = ggplot(data = plot_data, aes(x = X1, y = X2, color = !!sym(color_by)))+geom_point()+theme_bw()+labs( x = 'UMAP1', y = 'UMAP2')  
  }
  
  return(fig)
}


